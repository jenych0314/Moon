---
layout: post
title: "Java Script"
date: 2022-12-23
excerpt: "Java Script 공부"
tags: [Post, TIL, Java Script]
comments: true
---
<style>
    table, th, td {
        border: 1px solid black;
        /* border-collapse: collapse; */
        text-align: center; /*left, center, right*/
        text-vlign: middle; /*top, middle, bottom*/
    }
</style>

# Java Script
객체(object) 기반의 script 언어.
HTML로는 웹의 내용, CSS로는 웹의 디자인, JAVA SCRIPT로는 웹의 동작을 구현
주로 웹 브라우저에서 사용, Node.js와 같은 프레임워크를 사용하면 서버 측 프로그래밍에서도 사용 가능.

## 특징
1. 객체 기반의 스크립트 언어
2. 동적이며, 타입을 명시할 필요가 없는 인터프리터 언어
3. 객체 지향형 프로그래밍과 함수형 프로그래밍을 모두 표현 가능.

### 웹 프로그래밍에서 할 수 있는 일
1. HTML의 내용 변경
2. HTML의 속성 변경
3. HTML의 스타일 변경

## 문법
1. 세미콜론(;)으로 구분
2. 대소문자 구분
3. 리터럴(literal): 직접 표현되는 값 그 자체
4. 식별자(identifier): 변수/함수의 이름 작성 시 사용하는 이름. 영문자(대소문자), 숫자, 언더스코어(_), 달러($)만 사용 가능.
    1. 숫자로 시작 불가
    2. 유니코드 문자셋 사용
5. 식별자 작성 방식
    1. Camel Case: 식별자가 여러 단어로 이루어질 경우, 첫 번째 단어는 모두 소문자로 작서하고, 그 다음 단어부터는 첫 문자만 대문자로 작성하는 방식.
    2. Underscore Case: 식별자를 이루는 단어들을 소문자로만 작성하고, 그 단어들을 언더스코어(_)로 연결하는 방식.
6. 키워드(keyword)
7. 주석(comment)
```
1. 한 줄 주석: //
2. 여러 줄 주석: /**/
```

# 타입
## 기본 타입
1. 숫자(number): 정수와 실수 구분X -> 모든 수를 실수로 표현.
2. 문자열(string): 큰따옴표는 작은따옴표로 둘러싸인 문자열에만 포함될 수 있으며, 작은따옴표는 큰따옴표로 둘러싸인 문자열에만 포함될 수 있습니다.
3. 불리언(boolean)
4. 심볼(symbol): ECMAScript6부터 제공. 유일하고 변경할 수 없는 타입으로, 객체의 프로퍼티를 위한 식별자로 사용할 수 있습니다. 익스플로러에서 지원하지 않습니다.
5. undefined
* null: object 타입. 아직 값이 정해지지 않은 것을 의미
* undefined: 타입이 정해지지 않은 것. 초기화되지 않은 변수나 존재하지 않는 값.
6. 객체(object)
## 타입 변환
### 묵시적 타입 변환(implicit type conversion)
특정 타입의 값을 기대하는 곳에 다른 타입의 값이 오면, 자동으로 타입을 변환하여 사용함.
```
1 + "1" = 11
1 - "1" = 0
// 진짜 어질어질한 결과네 ㅋ
```
### 명시적 타입 변환(explicit type conversion)
1. Number()
2. String()
3. Boolean()
4. Object()
5. parseInt(): 문자열을 파싱해 특정 진법의 정수를 반환.
6. parseFloat(): 문자열을 파싱해 부동 소수점 수를 반환.
### 숫자를 문자열로 변환
1. toExponential(): 정수 부분은 1자리, 소수 부분은 입력받은 수만큼 e 표기법을 사용하여 숫자를 문자열로 변환함.
2. toFixed(): 소수 부분을 입력받은 수만큼 사용하여 숫자를 문자열로 변환함.
3. toPrecision(): 입력받은 수만큼 유효 자릿수를 사용하여 숫자를 문자열로 변환함.
### 날짜를 문자열이나 숫자로 변환
날짜(Date) 객체는 날짜를 숫자로 모두 변환 가능한 유일한 타입.
1. getDate(): 날짜 중 일자를 숫자로 반환함. (1 ~ 31)
2. getDay(): 날짜 중 요일을 숫자로 반환함. (일요일 : 0 ~ 토요일 : 6)
3. getFullYear(): 날짜 중 연도를 4자리 숫자로 반환함. (yyyy년)
4. getMonth(): 날짜 중 월을 숫자로 반환함. (1월 : 0 ~ 12월 : 11)
5. getTime(): 1970년 1월 1일부터 현재까지의 시간을 밀리초(millisecond) 단위의 숫자로 반환함.
6. getHours(): 시간 중 시를 숫자로 반환함. (0 ~ 23)
7. getMinutes(): 시간 중 분을 숫자로 반환함. (0 ~ 59)
8. getSeconds(): 시간 중 초를 숫자로 반환함. (0 ~ 59)
9. getMilliseconds(): 시간 중 초를 밀리초(millisecond) 단위의 숫자로 반환함. (0 ~ 999)
## 변수 선언과 초기화
1. var
2. let
3. const
# 연산자
## 비교연산자
==: 왼쪽 피연산자와 오른쪽 피연산자의 값이 같으면 참을 반환
===: 왼쪽 피연산자와 오른쪽 피연산자의 값이 같고, 같은 타입이면 참을 반환함.
!=: 왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않으면 참을 반환
!==: 왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않거나, 타입이 다르면 참을 반환함.
## 비트연산자
`>>>`: 지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨.
## 기타연산자
1. 삼항연산자
`표현식 ? 반환값1 : 반환값2`
결괏값이 참이면 반환값1을, 거짓이면 반환값2를 반환함.
2. delete 연산자
피연산자인 객체, 객체의 프로퍼티(property) 또는 배열의 요소(element) 등을 삭제해 줌. 피연산자가 성공적으로 삭제되었을 경우에는 참(true)을 반환하고, 삭제하지 못했을 경우에는 거짓(false)을 반환합니다.
3. typeof 연산자
피연산자의 타입 반환. 1항 연산자.
4. instanceof 연산자
피연산자인 객체가 특정 객체의 인스턴스인지 아닌지 확인.
피연산자가 특정 객체의 인스턴스이면 참(true)을 반환하고, 특정 객체의 인스턴스가 아니면 거짓(false)을 반환합니다.
`검사할 인스턴스 instanceof 검사할객체`
5. void 연산자
정의되지 않은 원시 타입의 값을 얻기 위해 사용. 언제나 undefined 값만 반환함.
# 제어문
## 반복문
1. for in 문
for / in 문은 해당 객체의 모든 열거할 수 있는 프로퍼티(enumerable properties)를 순회할 수 있도록 해줍니다.
열거할 수 있는 프로퍼티란 내부적으로 enumerable 플래그가 true로 설정된 프로퍼티를 의미합니다.
```
for (변수 in 객체) {
    객체의 모든 열거할 수 있는 프로퍼티의 개수만큼 반복적으로 실행하고자 하는 실행문;
}
```
2. for of 
for / of 문은 반복할 수 있는 객체(iterable objects)를 순회할 수 있도록 해주는 반복문입니다.
자바스크립트에서 반복할 수 있는 객체에는 Array, Map, Set, arguments 객체 등이 있습니다.
```
for (변수 of 객체) {

    객체의 모든 열거할 수 있는 프로퍼티의 개수만큼 반복적으로 실행하고자 하는 실행문;

}
```
for / of 문은 익스플로러에서 지원하지 않습니다.
## 기타 제어문
1. label 문
프로그램 내의 특정 영역을 식별할 수 있도록 해주는 식별자입니다.
label 문을 사용하면 continue 문과 break 문의 동작이 프로그램의 흐름을 특정 영역으로 이동시킬 수 있습니다.
```
label:
식별하고자 하는 특정 영역
```
2. continue 문
`continue 라벨이름;`
3. break 문
` break 라벨이름;`
## 배열
1. 배열 요소의 타입이 고정되어 있지 않으므로, 같은 배열에 있는 배열 요소끼리의 타입이 서로 다를 수도 있습니다.
2. 배열 요소의 인덱스가 연속적이지 않아도 되며, 따라서 특정 배열 요소가 비어 있을 수도 있습니다.
3. 자바스크립트에서 배열은 Array 객체로 다뤄집니다.
### 생성
```
1. var arr = [배열요소1, 배열요소2,...]; // 배열 리터럴을 이용하는 방법
2. var arr = Array(배열요소1, 배열요소2,...); // Array 객체의 생성자를 이용하는 방법
3. var arr = new Array(배열요소1, 배열요소2,...); // new 연산자를 이용한 Array 객체 생성 방법
```
### 배열 요소 추가
```
1. arr.push(추가할 요소);         // push() 메소드를 이용하는 방법
2. arr[arr.length] = 추가할 요소; // length 프로퍼티를 이용하는 방법
3. arr[특정인덱스] = 추가할 요소; // 특정 인덱스를 지정하여 추가하는 방법
```
### 연관 배열
숫자로 된 인덱스 대신에 문자열로 된 키(key)를 사용하는 배열을 연관 배열(associative array)
```
var arr = [];     // 비어있는 배열을 생성함.
arr["하나"] = 1;  // 숫자 인덱스 대신에 문자열을 인덱스로 배열 요소를 추가함.
arr["참"] = true;
arr["자바스크립트"] = "JavaScript";
document.write(arr["참"]);  // 문자열을 인덱스로 배열 요소에 접근할 수 있음.
document.write(arr.length); // 연관 배열은 Array 객체가 아니므로 length 프로퍼티의 값이 0임.
document.write(arr[0]);     // undefined
```
ECMAScript 6부터는 이러한 불편함을 해결하기 위해 새로운 데이터 구조인 Map 객체를 별도로 제공하고 있습니다.
### 배열 여부 확인
1. Array.isArray() 메소드
```
document.write(Array.isArray(arr));      // true
document.write(Array.isArray("문자열")); // false
```
2. instanceof 연산자
```
document.write(arr instanceof Array); // true
document.write(123 instanceof Array); // false
```
3. constructor 프로퍼티
```function isArray(a) {
    return a.constructor.toString().indexOf("Array") > -1;
}

var arr = [1, true, "JavaScript"];          // 배열 생성
document.write(arr.constructor);            // constructor 프로퍼티의 값 출력
document.write(arr.constructor.toString()); // function Array() {[native code]}
document.write(arr.constructor.toString().indexOf("Array")); // 10
document.write(isArray(arr))                // true
```
## 함수
자바스크립트에서는 함수도 하나의 타입(datatype)입니다.
따라서 함수를 변수에 대입하거나, 함수에 프로퍼티를 지정하는 것도 가능합니다.
또한, 자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수도 있습니다.
### 정의
자바스크립트에서 함수의 정의는 function 키워드로 시작되며, 다음과 같은 구성요소를 가집니다.
1. 함수의 이름
2. 괄호 안에 쉼표(,)로 구분되는 함수의 매개변수(parameter)
3. 중괄호({})로 둘러싸인 자바스크립트 실행문
```
function 함수이름(매개변수1, 매개변수2,...) {
    함수가 호출되었을 때 실행하고자 하는 실행문;
}
```
```
function sqr(x) {                // 제곱의 값을 구하는 함수 sqr를 정의함.
    return x * x;
}
var sqrNum = sqr;                // 변수 sqrNum에 함수 sqr을 대입함.
document.write(sqr(4) + "<br>"); // 함수 sqr을 호출함.
document.write(sqrNum(4));       // 변수 sqrNum를 함수처럼 호출함.
```
### 변수의 유효 범위
```
var num = 10; // 전역 변수 num을 선언함.
function globalNum() {
    var num = 20; // 같은 이름의 지역 변수 num을 선언함.
    document.write("함수 내부에서 지역 변수 num의 값은 " + num + "입니다.<br>");
    document.write("함수 내부에서 전역 변수 num의 값은 " + window.num + "입니다.<br>");
}
globalNum(); // 함수 globalNum()을 호출함.
```
### 매개변수
자바스크립트에서는 함수를 정의할 때는 매개변수의 타입을 따로 명시하지 않습니다.
함수를 호출할 때에도 인수(argument)로 전달된 값에 대해 어떠한 타입 검사도 하지 않습니다.
함수를 호출할 때 함수의 정의보다 적은 수의 인수가 전달되더라도, 다른 언어와는 달리 오류를 발생시키지 않습니다.
이 같은 경우 자바스크립트는 전달되지 않은 나머지 매개변수에 자동으로 undefined 값을 설정합니다.
### arguments 객체
```
function addNum() {
    var sum = 0; // 합을 저장할 변수 sum을 선언함.
    for(var i = 0; i < arguments.length; i++) { // 전달받은 인수의 총 수만큼 반복함.
        sum += arguments[i]; // 전달받은 각각의 인수를 sum에 더함.
    }
    return sum;
}

addNum(1, 2, 3); // 6
addNum(1, 2);    // 3
addNum(1);       // 1
addNum();        // 0
addNum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 55
```
### default parameter
매개변수의 기본값: undefined
디폴트 매개변수는 익스플로러, 사파리, 오페라에서 지원하지 않습니다.
### 나머지 매개변수(rest parameter)
나머지 매개변수는 생략 접두사(...)를 사용하여 특정 위치의 인수부터 마지막 인수까지를 한 번에 지정할 수 있습니다.
```
// 첫 번째 인수를 변수 firstNum에 저장하고 나머지 인수들은 배열 restArgs에 저장함.
function sub(firstNum, ...restArgs) {
    for(var i = 0; i < restArgs.length; i++) {
        firstNum -= restArgs[i];
    }
    return firstNum;
}
sub(10, 2, 3);    // 10 - 2 - 3 = 5
sub(10, 1, 5, 8); // 10 - 1 - 5 - 8 = -4
```
### predefined functions
1. eval(): eval() 함수는 문자열로 표현된 자바스크립트 코드를 실행하는 함수입니다.
`eval("문자열");`
2. isFinite():  전달된 값이 유한한 수인지를 검사하여 그 결과를 반환합니다. 만약 인수로 전달된 값이 숫자가 아니라면, 숫자로 변환하여 검사합니다.
`isFinite(검사할값);`
3. isNaN(): isNaN() 함수는 전달된 값이 NaN인지를 검사하여 그 결과를 반환합니다. 만약 인수로 전달된 값이 숫자가 아니라면, 숫자로 강제 변환하여 검사합니다.
`isNaN(검사할값);`
4. parseFloat()
5. parseInt()
6. decodeURI(): encodeURI() 함수나 다른 방법으로 만들어진 URI(Uniform Resource Identifier)를 해독합니다.
7. decodeURIComponent(): encodeURIComponent() 함수나 다른 방법으로 만들어진 URI 컴포넌트를 해독합니다.
8. encodeURI(): URI에서 주소를 표시하는 특수문자를 제외하고, 모든 문자를 이스케이프 시퀀스(escape sequences) 처리하여 부호화합니다.
9. encodeURIComponent(): URI에서 encodeURI() 함수에서 부호화하지 않은 모든 문자까지 포함하여 이스케이프 시퀀스 처리합니다.
10. escape(): 전달받은 문자열에서 특정 문자들을 16진법 이스케이프 시퀀스 문자로 변환합니다.
escape() 함수는 자바스크립트 1.5버전부터 더는 지원하지 않으므로, encodeURI() 함수나 encodeURIComponent() 함수를 대신 사용해야 합니다.
11. unescape(): 전달받은 문자열에서 escape() 함수나 다른 방법으로 만들어진 16진법 이스케이프 시퀀스 문자를 원래의 문자로 변환합니다.
unescape() 함수는 자바스크립트 1.5버전부터 더는 지원하지 않으므로, decodeURI() 함수나 decodeURIComponent() 함수를 대신 사용해야 합니다.
12. Number()
13. String()
## 객체
### 객체의 프로퍼티 참조
```
객체이름.프로퍼티이름
객체이름["프로퍼티이름"]
```
```
var person = {
    name: "홍길동",      // 이름 프로퍼티를 정의함.
    birthday: "030219",  // 생년월일 프로퍼티를 정의함.
    pId: "1234567",      // 개인 id 프로퍼티를 정의함.
    fullId: function() { // 생년월일과 개인 id를 합쳐서 주민등록번호를 반환함.
        return this.birthday + this.pId;
    }
};
person.name    // 홍길동
person["name"] // 홍길동
```
### 객체의 메소드 참조
`객체이름.메소드이름()`
```
var person = {
    name: "홍길동",
    birthday: "030219",
    pId: "1234567",
    fullId: function() {
        return this.birthday + this.pId;
    }
};
person.fullId() // 0302191234567
person.fullId;  // function () { return this.birthday + this.pId; } 
```
메소드를 참조할 때 메소드 이름 뒤에 괄호(())를 붙이지 않으면, 메소드가 아닌 프로퍼티 그 자체를 참조하게 됩니다. 따라서 괄호를 사용하지 않고 프로퍼티 그 자체를 참조하게 되면 해당 메소드의 정의 그 자체가 반환됩니다.
### 객체의 생성
1. 리터럴 표기(literal notation)를 이용한 방법
```
var 객체이름 = {
    프로퍼티1이름 : 프로퍼티1의값,
    프로퍼티2이름 : 프로퍼티2의값,
    ...
};
```
2. 생성자 함수(constructor function)를 이용한 방법
```
var day = new Date(); // new 연산자를 사용하여 Date 타입의 객체를 생성함.
document.write("올해는 " + day.getFullYear() + "년입니다.");
```
3. Object.create() 메소드를 이용한 방법
```
Object.create(프로토타입객체[, 새로운객체의프로퍼티1, 새로운객체의프로퍼티2, ...]);
```
```
var obj = Object.create(null, {             // null 프로토타입을 사용하여 새로운 객체를 만들고
    x: { value: 100, enumerable: true },    // x좌표를 나타내는 열거할 수 있는 프로퍼티와
    y: { value: 200, enumerable: true }     // y좌표를 나타내는 열거할 수 있는 프로퍼티를 추가함.
});
obj.x;                      // x좌표
obj.y;                      // y좌표 
Object.getPrototypeOf(obj); // 객체의 프로토타입을 반환해 줌.
```
### 상속
### 프로토타입(prototype)
자바스크립트의 모든 객체는 프로토타입(prototype)이라는 객체를 가지고 있음. 자바스크립트의 모든 객체는 최소한 하나 이상의 다른 객체로부터 상속을 받으며, 이때 상속되는 정보를 제공하는 객체를 프로토타입(prototype)이라고 함.
### 프로토타입 체인(prototype chain)
```
var obj = new Object(); // 이 객체의 프로토타입은 Object.prototype입니다.
var arr = new Array();  // 이 객체의 프로토타입은 Array.prototype입니다.
var date = new Date();  // 이 객체의 프로토타입은 Date.prototype입니다.
```
프로토타입이 상속되는 가상의 연결 고리를 프로토타입 체인(prototype chain)이라고 합니다. Object.prototype 객체는 이러한 프로토타입 체인에서도 가장 상위에 존재하는 프로토타입입니다. 따라서 자바스크립트의 모든 객체는 Object.prototype 객체를 프로토타입으로 상속받습니다.
### 프로토타입의 생성
```
function Dog(color, name, age) { // 개에 관한 생성자 함수를 작성함.
    this.color = color;          // 색에 관한 프로퍼티
    this.name = name;            // 이름에 관한 프로퍼티
    this.age = age;              // 나이에 관한 프로퍼티
}
var myDog = new Dog("흰색", "마루", 1); // 이 객체는 Dog라는 프로토타입을 가짐.
document.write("우리 집 강아지는 " + myDog.name + "라는 이름의 " + myDog.color + " 털이 매력적인 강아지입니다.");
```
### 객체의 프로퍼티 및 메소드 추가
```
function Dog(color, name, age) {
    this.color = color;
    this.name = name;
    this.age = age;
}
var myDog = new Dog("흰색", "마루", 1);
myDog.family = "시베리안 허스키"; // 품종에 관한 프로퍼티를 추가함.
myDog.breed = function() {        // 털색을 포함한 품종을 반환해 주는 메소드를 추가함.
    return this.color + " " + this.family;
}
document.write("우리 집 강아지는 " + myDog.breed() + "입니다.");
```
### 프로토타입에 프로퍼티 및 메소드 추가
```
function Dog(color, name, age) {
    this.color = color;
    this.name = name;
    this.age = age;
    this.family = "시베리안 허스키"; // 프로토타입에 프로퍼티를 추가할 때에는 기본값을 가지게 할 수 있음.
    this.breed = function() {
        return this.color + " " + this.family;
    };
}
var myDog = new Dog("흰색", "마루", 1);
var hisDog = new Dog("갈색", "콩이", 3);
document.write("우리 집 강아지는 " + myDog.family + "이고, 친구네 집 강아지도 " + hisDog.family + "입니다.");
```
### prototype 프로퍼티
```
function Dog(color, name, age) {
    this.color = color;
    this.name = name;
    this.age = age;
}
// 현재 존재하고 있는 Dog 프로토타입에 family 프로퍼티를 추가함.
Dog.prototype.family = "시베리안 허스키";
// 현재 존재하고 있는 Dog 프로토타입에 breed 메소드를 추가함.
Dog.prototype.breed = function() {
    return this.color + " " + this.family;
};
var myDog = new Dog("흰색", "마루", 1);
var hisDog = new Dog("갈색", "콩이", 3);

document.write("우리 집 강아지는 " + myDog.family + "이고, 친구네 집 강아지도 " + hisDog.family + "입니다.");
document.write("우리 집 강아지의 품종은 " + myDog.breed() + "입니다.<br>");
document.write("친구네 집 강아지의 품종은 " + hisDog.breed() + "입니다.");
```
직접 생성한 프로토타입은 위와 같이 새로운 프로퍼티나 메소드를 마음껏 추가하거나 삭제할 수 있습니다. 물론 자바스크립트 표준 객체의 프로토타입도 임의로 수정할 수 있으나, 심각한 오류가 발생할 가능성이 있습니다. 따라서 자바스크립트 표준 객체의 프로토타입은 수정해서는 안됩니다.
### this 키워드
### 객체 프로퍼티의 삭제
`delete 객체이름.프로퍼티이름;`
```
function Dog(color, name, age) {
    this.color = color;
    this.name = name;
    this.age = age;
}
var myDog = new Dog("흰색", "마루", 1);
delete myDog.age; // age 프로퍼티를 삭제함.
// age 프로퍼티가 삭제되었기 때문에 undefined를 출력함.
document.write("우리집 강아지의 나이는 " + myDog.age + "입니다.");
```
### 객체 프로퍼티의 순회
1. Object.keys()
2. Object.getOwnPropertyNames()
### 객체간의 비교
객체 레퍼런스는 객체 자체를 저장하는 것이 아니라, 객체가 위치한 주소를 저장하는 것입니다.
### 객체 메소드(method)
1. hasOwnProperty(): 특정 프로퍼티가 해당 객체에 존재하는지를 검사합니다. 해당 객체에서 직접 선언된 프로퍼티만을 검사하며, 같은 이름의 프로퍼티라도 상속받은 프로퍼티는 false 값을 반환합니다.
```
function Dog(color, name, age, family) {
    this.color = color;
    this.name = name;
    this.age = age;
    this.family = family;
    this.breed = function() {
        return this.color + " " + this.family;
    }
}
var myDog = new Dog("검정색", "곰", 3, "불독");
myDog.hasOwnProperty("color"); // true
myDog.hasOwnProperty("breed"); // true
myDog.hasOwnProperty("class"); // 상속받은 프로퍼티이므로, false를 반환함.
```
2. propertyIsEnumerable(): 특정 프로퍼티가 해당 객체에 존재하고, 열거할 수 있는 프로퍼티인지를 검사합니다. 즉, 이 메소드는 hasOwnProperty() 메소드의 결과가 true이면서, 동시에 열거할 수 있는 프로퍼티인지를 검사합니다.
3. isPrototypeOf(): 특정 객체의 프로토타입 체인에 현재 객체가 존재하는지를 검사합니다.
4. isExtensible(): 객체에 새로운 프로퍼티를 추가할 수 있는지 여부를 반환합니다.
자바스크립트에서 모든 객체는 기본적으로 새로운 프로퍼티를 추가할 수 있습니다. 하지만 preventExtensions() 메소드를 사용하여 해당 객체에 새로운 프로퍼티를 추가할 수 없도록 설정할 수 있습니다.
5. toString(): 이 메소드를 호출한 객체의 값을 문자열로 반환합니다.
6. valueOf(): 특정 객체의 원시 타입(primitive type)의 값을 반환합니다.
자바스크립트에서는 원시 타입의 값이 기대되는 곳에 객체가 사용되면, 내부적으로 이 메소드를 호출하여 처리합니다.
만약 어떤 객체가 원시 타입의 값을 가지고 있지 않다면, 이 메소드는 객체 자신을 반환합니다.
```
function func(n) {
    this.number = n;
}
myFunc = new func(4);
document.write(myFunc + 5); // ① : [object Object]5

func.prototype.valueOf = function() { // valueOf() 메소드를 정의함.
    return this.number;
}
document.write(myFunc + 5); // ② : 9
```
### getter와 setter 메소드의 정의
